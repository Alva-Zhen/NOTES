1. js在HTML中，在head中引用和在底部引用的区别，js同步和异步
2. 原型链
    每个构造函数都有一个原型对象 prototype，原型对象 prototype 都有一个指针 constructor 指向构造函数，每个对象都有一个属性__proto__指向原型对象，让原型对象等于另一个构造函数的实例，那么这个原型对象的属性__proto__就会指向另一个构造函数的原型对象，这样层层递进，就形成了原型链。
3. 深拷贝浅拷贝

    浅拷贝：拷贝第一层，与原来的拷贝对象还有点关系。

    深拷贝：多层全部拷贝下来，与原来的拷贝对象没有关系。

    深拷贝和浅拷贝的区别是内存中存储类型不同。基本数据类型的值和大小是固定的，存储在栈中，释放的时候是系统自动释放；引用类型是存储在堆中，大小是动态分配的，不会自动释放。对于一个基本数据类型，例如一个变量a=1；我将a的值赋给变量b，会在栈中生成一个a的副本，对于对象，如果以赋值方法将一个对象付给另一个变量，只是将一个指针付给了这个变量，然后，需要我们对于堆中的对象也进行复制，对于对象中的引用类型没有进行复制的是浅拷贝，对于对象中引用类型也进行复制的是深拷贝。

4. new过程

    创建一个新对象；
    将新对象的__proto__指向构造函数的原型对象；
    将构造函数的this指向新对象；
    将新对象返回给实例。

    function A(){};
    var b=new A()

    首先创建一个空对象例如：var o=new Object()；
    然后将o.__proto__指向A.protype；
    然后将A的this指向o：A.call(o)；
    最后将o返回给b

5. 判断数据类型（typeof  incetanceof区别）

    typeof：判断基本类型，返回undefined，boolean，string，number，返回相应的字符串，对于null，object，array等返回object，对于function类型返回function。

    incetanceof：判断引用类型，原理是根据构造函数来判断。

    Object.prototypr.toString.call()：返回相应的数据类型。

6. 回流和重绘

    回流：引起浏览器部分内容或是全部内容重新渲染。

    重绘：没有引起重新渲染，只是改变基本样式，比如字体大小、背景颜色等。

7. 防抖和节流

    防抖：将多次执行的事件合并为一次执行，并在触发后一段时间在执行方法。

    节流：每隔一段时间执行一次事件。

8. 同步和异步

    同步：在主线程上可以得到返回值的。

    异步：在主线程上得不到返回值的。

9. 事件循环

10. 闭包

    有权访问另一个函数作用域中的变量的函数。

    创建闭包的常见方式是在一个函数返回另一个函数。

    缺点：

        内存泄漏。因为匿名函数会在外部被调用，导致外层函数的变量对象一直被引用，一直存放在内存中，无法清除。解决办法是清除匿名函数。

        this指向window。匿名函数的执行环境具有全局性，所以匿名函数中的this是指向全局的，所以需要记录一下外层函数的this值，才能传到匿名函数中。

11. 作用域链

    当我们调用一个函数时，会创建这个函数的执行环境，执行环境分为函数执行环境和全局执行环境，每个执行环境都有一个变量对象，这个变量对象是我们没有办法访问的，变量对象是保存着我们定义的变量和函数，然后我们在查找一个变量的时候，会先从当前执行环境的变量对象上查找，如果没有找到，在向上延伸到外层作用域的变量对象上查找，知道全局作用域的变量对象，这种形式，会形成作用域链。


    当我们调用一个函数时，会创建这个函数的执行环境；执行环境又称为执行上下文，他定义了变量或函数有权访问的其他数据，决定了他们的各自行为。最外围的执行环境称为全局执行环境，在 web 浏览器中，被认为是 window 对象；每个执行环境都有一个变量对象，这个对象我们是无法访问的，变量对象上保存的是当前执行环境中定义的函数和变量。当我们查找一个变量时，会先从当前执行环境的变量对象上查找，找到了则返回这个变量，如果没有找到，会去父级执行环境的变量对象上查找，知道全局执行环境的变量对象，这种形式，会形成作用域链。作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。

12.高阶函数

    高阶函数就是函数的参数是一个函数；或是返回一个函数，这样的函数叫做高阶函数。

13.let、const、var区别

    都是定义变量。

    var具有变量提升。

    let、const没有变量提升，存在暂时性死区。

    const定义的是常量，不能修改。
    
    在JavaScript中是没有块级作用域的，使用let可以出现块级作用域。